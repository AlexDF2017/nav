#!/usr/bin/perl
####################
#
# $Id: nav,v 1.2 2003/05/26 12:19:36 mortenv Exp $
# This file is part of the NAV project.
# Common start/stop script for all NAV daemons.  It will also manage
# loading/unloading of cron-based tasks in the NAV system.
#
# Copyright (c) 2002 by NTNU, ITEA nettgruppen
# Authors: Morten Vold <morten.vold@itea.ntnu.no>
#
####################
use strict;
use English;

use constant SUB_NONE    => 0;
use constant SUB_SAME    => 1;
use constant SUB_DIFF    => 2;
use constant SUB_UNKNOWN => 255;

my $NAV_ROOT = '/usr/local/nav';
my $NAV_CONF = "$NAV_ROOT/local/etc/conf/nav.conf";
my $NAVME_ETC = "$NAV_ROOT/navme/etc";
my $NAVME_INIT = "$NAVME_ETC/init.d";
my $CRONFILE = "$NAVME_ETC/crontab_navcron.nav";
my $CRONTAB = 'crontab';
my $NAVCRON_USER = 'navcron';
my $PREFIXNAME = '<PREFIX>';
my @UNKNOWNLIST = ();

if ($EUID != 0) {
    print "You must be root to run this program.\n";
    exit 1;
}

die "$CRONFILE does not exist" unless (-f $CRONFILE);
chdir($NAVME_INIT);

use NAV;
my %navconf = &NAV::config($NAV_CONF);

my %crontasks = &parseCronFile();
my $tempbuffer = `$CRONTAB -u $NAVCRON_USER -l`;
my %runningcrontasks = &parseCronBuffer($tempbuffer);

$|=1;
if ($#ARGV == -1) {
    &printUsage();
    exit 1;
}

my $command = shift;
if ($#ARGV == -1) {
    @ARGV = keys %crontasks;
    push(@ARGV, &listDaemons());
}

foreach ($command) {
    /^status$/ && do {
        print "== NAV Daemons ==\n";
        &daemonCommand('status', @ARGV);
        print "== NAV Cron-based tasks ==\n";
        @ARGV = @UNKNOWNLIST; @UNKNOWNLIST = ();
        &printCronStatus(@ARGV);
        last;
    };
    /^start$/ && do {
        print "== NAV Daemons ==\n";
        &daemonCommand('start', @ARGV);
        print "== NAV Cron-based tasks ==\n";
        @ARGV = @UNKNOWNLIST; @UNKNOWNLIST = ();
        &startCrontasks(@ARGV);
        last;
    };
    /^stop$/ && do {
        print "== NAV Daemons ==\n";
        &daemonCommand('stop', @ARGV);
        print "== NAV Cron-based tasks ==\n";
        @ARGV = @UNKNOWNLIST; @UNKNOWNLIST = ();
        &stopCrontasks(@ARGV);
        last;
    };
    /^restart$/ && do {
        print "== NAV Daemons ==\n";
        &daemonCommand('restart', @ARGV);
        @ARGV = @UNKNOWNLIST; @UNKNOWNLIST = ();
        if (@ARGV) {
            print "== Stopping NAV Cron-based tasks ==\n";
            &stopCrontasks(@ARGV);
            print "== Starting NAV Cron-based tasks ==\n";
            &startCrontasks(@ARGV);
        }
        last;
    };
    /^list$/ && do {
        print "== NAV Daemons ==\n";
        foreach (&listDaemons()) {
            print "$_\n";
        }
        print "== NAV Cron-based tasks ==\n";
        foreach (keys %crontasks) {
            print "$_\n" unless ($_ eq $PREFIXNAME);
        }
        last;
    };
    /^ver$/ && do {
        &printNAVVersion();
        last;
    };

    # Print error when command is unknown
    print STDERR "Unknown command '$_'\n";
    exit 1;
}

# If service names were unknown to both the daemon and cron systems, they will
# be listed in the @UNKNOWNLIST array, and we complain about it here.
if ($#UNKNOWNLIST > -1) {
    print "\nThe following specified subsystems are unknown:\n";
    foreach (@UNKNOWNLIST) {
        print "$_ ";
    }
    print "\n";
}

##########################

sub parseCronBuffer ($)
{
    my $buffer = shift;
    my %crontasks;

    # Nice regex to parse the sectioned crontab file :-)
    while ($buffer =~ /\n(\#\s*<(.+?)>\s*?\r?\n(.+?)\n\#\s*<\/\2>)/sg) {
        # If this is the first match, interpret the data preceding the
        # match as the prefix section.
        unless (exists($crontasks{$PREFIXNAME})) {
            $crontasks{$PREFIXNAME} = $`;
        }
        $crontasks{$2} = $1;
    }

    # If no sections were found in the buffer, treat the entire buffer
    # as the prefix section.
    unless (exists($crontasks{$PREFIXNAME})) {
        $crontasks{$PREFIXNAME} = $buffer;
    }
    # Drop any comments and empty lines in the prefix section.
    $crontasks{$PREFIXNAME} =~ s/^\#.*$//mg;
    while ($crontasks{$PREFIXNAME} =~ s/(\r?\n){2}/\n/sg) {};

    if (defined($navconf{ADMIN_MAIL})) {
        # Replace internal variables in all chunks...
        foreach (keys %crontasks) {
            $crontasks{$_} =~ s/\Q%ADMIN_MAIL%\E/$navconf{ADMIN_MAIL}/sg;
        }
    }

    return %crontasks;
}

sub parseCronFile ()
{
    open(my $FD, "<$CRONFILE") || die "Cannot open $CRONFILE ($!)";
    read($FD, my $buffer, -s $CRONFILE);
    close($FD);
    
    return &parseCronBuffer($buffer);
}

sub printUsage ()
{
    print <<EOF;
Usage: nav [command] [subsystem1 ... subsystemN]
Where [command] is one of:

        status  - Show status of subsystem(s)
        start   - Start subsystem(s)
        stop    - Stop subsystem(s)
        restart - Stop and then start subsystem(s)
        list    - List known subsystems
        ver     - Display NAV version

If subsystem is omitted, commands will be performed on all known subsystems.

EOF
}

sub cronStatus ($)
{
    my $crontask = shift;

    # If the system does not appear in the navme crontab file, it is
    # unknown to us.
    return SUB_UNKNOWN unless (exists($crontasks{$crontask}));
    
    if (exists($runningcrontasks{$crontask})) {
        if ($runningcrontasks{$crontask} eq $crontasks{$crontask}) {
            return SUB_SAME;
        } else {
            return SUB_DIFF;
        }
    } else {
        return SUB_NONE;
    }
}

sub printCronStatus
{
    my %messages = (
                    &SUB_NONE => "Down",
                    &SUB_SAME => "Up",
                    &SUB_DIFF => "Seems to be up, but modified from version on disk",
                    &SUB_UNKNOWN => "Unknown subsystem!"
                    );

    my $prefixCheck = 0;
    while (my $crontask = shift) {
        if ($crontask eq $PREFIXNAME) {
            $prefixCheck = 1;
        } else {
            my $status = &cronStatus($crontask);
            if ($status == SUB_UNKNOWN) {
                push(@UNKNOWNLIST, $crontask);
            } else {
                print "$crontask: $messages{$status}\n";
            }
        }
    }

    if ($prefixCheck) {
        # Check the status of the prefix section
        my $prefixStatus = &cronStatus($PREFIXNAME);
        if ($prefixStatus != SUB_SAME) {
            if ($prefixStatus == SUB_DIFF) {
                print "\nThe running prefix section is different than the one on disk!\n";
            } elsif ($prefixStatus == SUB_NONE) {
                print "\nWARNING: The prefix section is missing, NAV might not be functioning properly!\n";
            } elsif ($prefixStatus == SUB_UNKNOWN) {
                print "\nWARNING: The prefix section is unknown, something is very wrong with the system!\n";
            }
        }
    }
}

sub startCrontasks
{
    # Always reload the prefix when adding stuff to the crontab.
    $runningcrontasks{$PREFIXNAME} = $crontasks{$PREFIXNAME};

    # This loop updates the %runningcrontasks hash to reflect what the
    # new crontab will look like.
    foreach my $crontask (@_) {
        next if ($crontask eq $PREFIXNAME); # Skip prefix section

        my $status = &cronStatus($crontask);
        if ($status == SUB_UNKNOWN) {
            push(@UNKNOWNLIST, $crontask);
            next;
        }

        print "$crontask: ";
        if ($status == SUB_SAME) {
            print "Already up\n";
        } else {
            if ($status == SUB_DIFF) {
                print "Reloading from disk\n";
            } elsif ($status == SUB_NONE) {
                print "Adding\n";
            }
            $runningcrontasks{$crontask} = $crontasks{$crontask};
        }
    }

    &updateCrontab();
}

sub stopCrontasks
{
    # This loop updates the %runningcrontasks hash to reflect what the
    # new crontab will look like.
    foreach my $crontask (@_) {
        next if ($crontask eq $PREFIXNAME); # Skip prefix section
        print "$crontask: ";
        my $status = &cronStatus($crontask);
        if ($status == SUB_UNKNOWN) {
            print "Unknown subsystem!\n";
        } elsif ($status == SUB_SAME or $status == SUB_DIFF) {
            print "Removing\n";
            delete($runningcrontasks{$crontask});
        } elsif ($status == SUB_NONE) {
            print "Not up\n";
        }
    }
    &updateCrontab();
}

sub updateCrontab
{
    # Open pipe to crontab
    open(my $CRONFD, "| $CRONTAB -u $NAVCRON_USER -") 
        || die "Cannot run $CRONTAB ($!)(" . ($? >> 8) . ")";
    
    print $CRONFD $runningcrontasks{$PREFIXNAME};
    foreach (keys %runningcrontasks) {
        next if ($_ eq $PREFIXNAME);
        print $CRONFD "\n$crontasks{$_}\n";
    }
    close($CRONFD);
    my $exit_status = $? >> 8;
    if ($exit_status != 0) {
        print STDERR "ERROR: $CRONTAB exited with a value of $exit_status\n";
    }
}

#
# Return an array of known daemon names.
#
sub listDaemons
{
    opendir(my $INIT, $NAVME_INIT);
    # Make a list of found init scripts, excluding files with leading
    # dots, files with backup prefixes and known non-init files
    my @entries = grep { /^[^.]/ && !/\~$/ && !/^nav$/ && !/^functions$/ } readdir($INIT);
    closedir($INIT);
    return @entries;
}

#
# Run a command string through a list of  daemon init scripts.
#
sub daemonCommand ($@)
{
    my $command = shift;
    my @targetdaemons = @_;
    my %daemonlist = map { $_ => 1 } &listDaemons();

    while (my $daemon = shift @targetdaemons) {
        unless (exists($daemonlist{$daemon})) {
            push(@UNKNOWNLIST, $daemon);
        } else {
            system("./$daemon $command") == 0 
                or print "Failed to run init script for $daemon ($!, $?)\n";
        }
    }
}

sub printNAVVersion
{
    my $verfile = "$NAV_ROOT/navme/version.nav";
    open(my $FD, "<$verfile") or die "Error opening $verfile ($!)";
    chomp(my $verstring = <$FD>);
    close($FD);

    # Remove any CVS keywords (The \Q quotation is to stop CVS from expanding
    # the regex as a keyword.
    $verstring =~ s/(\$\QName\E:)?\s*(\S+?)\s*\$/$2/i;
    # Remove any leading textual name from a CVS tag name
    $verstring =~ s/\w+-(.+)/$1/;
    # Replace dashes with dots
    $verstring =~ tr/-/./;

    print "Your NAV version is: $verstring\n";
}

### Local Variables: ###
### Mode: perl ###
### indent-tabs-mode: nil ###
### fill-column: 79 ###
### End: ###
