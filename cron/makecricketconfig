#!/usr/bin/perl -w
####################
#
# $Id: makecricketconfig,v 1.2 2002/11/27 13:10:41 bredal Exp $
# This file is part of the NAV project.
# Script som lager alle target-filene som Cricket bruker
# ved innsamling av data.
#
# Poenget med scriptet er at det ikke skal bruke SNMP 
# for å spørre enhetene om info, da dette fører til timeout på
# enheter som er nede, og dermed fører til mangelfull innsamling
# av data for Cricket.
#
# For mer informasjon se:
# http://metanav.ntnu.no/v2/systemdok/cricketconfig.html
#
# Copyright (c) 2002 by NTNU, ITEA nettgruppen
# Author: John Magne Bredal <bredal@itea.ntnu.no>
#
####################

use strict;
require ('/usr/local/nav/navme/lib/NAV.pm');
import NAV;

if ($< == 0) {
    print "You cannot run this script as root. Use a NAV-user, preferably navcron.\n";
    exit(1);
}

my $cricketpath = "/home/navcron/cricket";
my $path = "$cricketpath/cricket-config";
my $default = "$cricketpath/cricket-config_defaults";
my $antallting = 0;

my @ruterliste;
my @switchliste;

my $dbh = &db_get("trapdetectmanage");

# Sletter alt for å forhindre at det blir liggende feil igjen fra
# forrige oppdatering.

my $time = `date +%d-%m-%Y\\ %H:%M:%S`;
my $starttime = time();

print "--- MAKECRICKETCONFIG ---\n";
print "Starting build at $time\n";
print "Deleting old configfiles...";

!system("rm -Rf $path/router-interfaces/*") or die "\nCould not delete $path/router-interfaces/*\n$?\n";
!system("rm -Rf $path/switch-ports/*") or die "\nCould not delete $path/switch-ports/*\n$?\n";
!system("rm -Rf $path/giga-router-interfaces/*") or die "\nCould not delete $path/giga-router-interfaces/*\n$?\n";
!system("rm -Rf $path/giga-switch-ports/*") or die "\nCould not delete $path/giga-switch-ports/*\n$?\n";
!system("rm -Rf $path/switches/*") or die "\nCould not delete $path/switches/*\n$?\n";
!system("rm -Rf $path/routers/*") or die "\nCould not delete $path/routers/*\n$?\n";
#!system("rm -Rf $path/andre-switch-ports/*") or die "\nCould not delete $path/andre-switch-ports/*\n$?\n";
print "OK.\n";

print "Copying default configfiles to target-directory...";
!system("cp -R $default/* $path") or die "copy failed: $?\n";
print "OK.\n\n";

print "Writing routers\n";
&Routers;
print "OK!\n\n";

print "Writing router-interfaces\n";
&Routerinterfaces;
print "OK!\n\n";

print "Writing switches\n";
&Switches;
print "OK!\n\n";

print "Writing switchports\n";
&Switchports;
print "OK!\n\n";

print "Writing gigarouterinterfaces\n";
&gigarouterinterfaces;
print "OK!\n\n";

print "Writing gigaswitchports\n";
&gigaswitchports;
print "OK!\n\n";

#print "Writing andre-switchports\n";
#&andre_switchports;
#print "OK!\n\n";

print "Compiling new config-tree\n";
!system("$cricketpath/cricket/compile") or warn "\nCompile failed!\n";

print "Done!\n";

my $stoptime = time();
my $difference = $stoptime - $^T;
my $minutes = int ($difference / 60);
my $seconds = $difference % 60;
my $minutetext = "";
if ($minutes > 0) {
    $minutetext = "$minutes ";
    if ($minutes == 1) { $minutetext .= "minute and " }
    else { $minutetext .= "minutes and " }
}
print "Making and compiling the config-tree took $minutetext$seconds seconds.\n\n";

########################################
# Henter info om ruterne
########################################
sub Routers {

    my $fil = "$path/routers/Targets";
    my $routercount = 0;

    # Henter alle ruterne fra databasen
    my $sporring = "SELECT netboxid,sysname,ip,typegroupid,roomid,ro,descr FROM netbox JOIN type USING (typeid) WHERE (catid='GW' OR catid='GSW') ORDER BY sysname";
    my $getrouters = &db_select($dbh,$sporring);

    # Skriver til filen
    open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
    while (my @temp = $getrouters->fetchrow) {
	my ($id, $sysname,$ip,$typegruppe,$romid,$community,$boksdesc) = @temp;
	
	# Unngår hvis det er feil i databasen
	if ($sysname && $community) {
	    push @ruterliste, [$id, $sysname, $ip, $romid,$community];
	    if ($typegruppe) {
		$routercount++;
		$antallting++;
		print FIL "target $sysname\n";
		print FIL "\tsnmp-host\t=\t$ip\n";
		print FIL "\tsnmp-community\t=\t$community\n";
		print FIL "\ttarget-type\t=\t$typegruppe\n";

		# Må finne beskrivelsen til rommet
		$sporring = "SELECT descr FROM room WHERE roomid='$romid'";
		my $getdesc = &db_select($dbh,$sporring);
		my $desc = $getdesc->fetchrow;
		print FIL "\tshort-desc\t=\t\"$boksdesc, $desc\"\n\n";
	    }
	} else {
	    print "MAJOR ERROR: sysname or community not returned from query, skipping unit with ip $ip\n";
	}
    }

    close FIL;
    print "$routercount routers written.\n";

} # sub Routers

########################################
# Henter info om interfaces, bruker
# ruterlista.
########################################
sub Routerinterfaces {

    my $interfacecount = 0;
    my $routercount = 0;
    for (@ruterliste) {
	$routercount++;
	my %routerint = ();
	my ($ruterid, $sysname, $ip, $romid, $community) = @$_;

	unless (-e "$path/router-interfaces/$sysname") {
	    mkdir ("$path/router-interfaces/$sysname",0775);
	}

	my $fil = "$path/router-interfaces/$sysname/interfaces";
	open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
	print FIL "target --default--\n";
	print FIL "\trouter = $ip\n";
	print FIL "\tsnmp-community =\t$community\n";

	# Må finne alle interfacene til ruteren
	my $sporring = "SELECT interface,speed,netident,nettype,descr FROM gwport LEFT JOIN prefix using (prefixid) WHERE netboxid=$ruterid AND speed!=1000 and masterindex is null";

	my $getinterfaces = &db_select($dbh,$sporring);
	
	my @liste;
	my ($interf,$speed,$nettident,$nettype,$komm);
	my $interfacedesc;
	while (($interf,$speed,$nettident,$nettype,$komm) = $getinterfaces->fetchrow) {
	    unless ($routerint{$interf}) {
		$routerint{$interf}++;
		# Setter sammen description
		if ($nettype || $nettident || $komm) {
                    unless ($nettype) {$nettype = "";}
                    unless ($nettident) {$nettident = "";}
                    unless ($komm) {$komm = "";}
		    $interfacedesc = join (' ', $nettype,$nettident,$komm);
		} else {
		    $interfacedesc = "Ingen beskrivelse tilgjengelig";
		}
		# Vil ikke ha med Loopback-interfacene.
		unless ($interf =~ /Loopback/) {
		    push @liste, [$interf,$speed,$interfacedesc];
		}
	    }
	}

	@liste = &sorter(0, @liste);
	my $order = @liste;

	for (@liste) {
	    $interfacecount++;
	    $antallting++;
	    ($interf,$speed,$interfacedesc) = @$_;

	    $interf =~ s/\//_/g;
	    print FIL "\ntarget \"$interf\"\n";
	    $interf =~ s/_/\//g;
	    print FIL "\tinterface-name\t=\t\"$interf\"\n";

	    # Legger inn sjekk for om dette er et subinterface, i så fall
	    # skal target-type være sub-interface.
	    if ($interf =~ m/(.*)\.\d+/) {
		# Dette er et subinterface.
		print "Subinterface found: $interf\n";
		print FIL "\ttarget-type\t=\tsub-interface\n";
	    }

	    print FIL "\tshort-desc\t=\t\"$interfacedesc\"\n";

	    # Setter slik at alle capacities har .00 etter seg
	    if ($speed =~ /\./) {
		print FIL "\tcapacity\t=\t$speed\n";
	    } else {
		print FIL "\tcapacity\t=\t$speed.00\n";
	    }
	    $order--;
	    print FIL "\torder\t\t=\t$order\n\n";
	}

	close FIL;
    }
    print "$interfacecount interfaces written, dispersed on $routercount routers.\n"

} # sub Routerinterfaces

########################################
# Henter info om alle svitsjene.
# Tar hensyn til at det brukes både
# svitsjer og rutere...
########################################
sub Switches {

    my $fil = "$path/switches/switches";
    my $switchcount = 0;

    my $sporring = "SELECT netboxid,ip,sysname,vendorid,typename,typegroupid,ro,descr FROM netbox JOIN type USING (typeid) WHERE catid~*'^SW\$' AND vendorid !~* '3com' ORDER BY sysname";
    my $getswitches = &db_select($dbh,$sporring);

    open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
    while (my @temp = $getswitches->fetchrow) {
	my ($id, $ip, $sysname, $vendorid, $typename, $typegruppe, $community, $boksdesc) = @temp;
	# Unngår feil i databasen
	if ($sysname && $community) {
	    push @switchliste, [$id, $ip, $sysname, $typename, $community];	    
	    if ($typegruppe) {
		$switchcount++;
		$antallting++;
		print FIL "target $sysname\n";
		print FIL "\tsnmp-host\t=\t$ip\n";
		print FIL "\tsnmp-community\t=\t$community\n";
		print FIL "\ttarget-type\t=\t$typegruppe\n";
		print FIL "\tshort-desc\t=\t\"$boksdesc\"\n\n";
	    }
	} else {
	    print "MAJOR ERROR: sysname or community not returned in query, skipping unit with ip $ip\n";
	}
    }
    close FIL;

    print "$switchcount switches written.\n";

} # sub Switches


########################################
# Henter info om svitsjeportene.
########################################
sub Switchports {

    my $switchcount = 0;
    my $portcount = 0;

    for (@switchliste) {
	$switchcount++;
	my ($id, $ip, $switchnavn, $typename, $community) = @$_;

	if ($community && $typename !~ /C1900or/i) {
	    # Finner alle portene som er på switchen.
	    my $sporring = "SELECT module,port,portname,sysname FROM swport LEFT JOIN netbox ON (swport.to_netboxid=netbox.netboxid) JOIN module USING (moduleid) WHERE module.netboxid=$id AND speed!=1000 AND link='y' ORDER BY swportid";
	    my $getports = &db_select($dbh,$sporring);
	    my $antall = $getports->ntuples;

	    # Hvis ingenting returneres skal vi ikke gjøre noe.
            unless ($antall == 0) {
                unless (-e "$path/switch-ports/$switchnavn") {
                    mkdir ("$path/switch-ports/$switchnavn", 0775);
                }
		
		my $fil = "$path/switch-ports/$switchnavn/ports";

		open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
		print FIL "target --default--\n";
		print FIL "\tswitch\t\t=\t$ip\n";
		print FIL "\tsnmp-community\t=\t$community\n\n";

		my @liste;
		
		while (my @temp = $getports->fetchrow) {
		    my ($modul,$port,$portname,$boksbak) = @temp;
		    unless (!$port) {
			unless ($typename =~ /2524/i) {
			    $port = $modul."_".$port;
			}
			if ($portname || $boksbak) {
			    $portname = $portname || $boksbak;
			    push @liste, [$port,$portname];
			} else {
			    $portname = "Intet portnavn definert";
			    push @liste, [$port,$portname];
			}
		    }
		}

		@liste = &sorter(0,@liste);

		# Order holder styr på rekkefølgen som Cricket
		# viser portene i. Høyt tall = høy prioritet.
		my $order = @liste;
		
		for my $ref (@liste) {
		    $portcount++;
		    $antallting++;
		    my ($port, $portname) = @$ref;
		    $port =~ s/fe/Fa/i;
		    $port =~ s/ge/Gi/i;
		    print FIL "target \"$port\"\n";
		    $port =~ s/_/\//;
		    print FIL "\tport-name\t=\t\"$port\"\n";
		    $portname =~ s/\s/_/g;
		    print FIL "\tshort-desc\t=\t\"$portname\"\n";

		    $order--;
		    print FIL "\torder\t\t=\t$order\n\n";
		}
		close FIL;
	    }
	}
    }
    print "$portcount ports written, dispersed on $switchcount switches.\n"

} # sub Switchports

sub gigarouterinterfaces {

    my $interfacecount = 0;
    my $routercount = 0;
    my $teller = 0;
    # Henter alle interfaces som har giga-kapasitet.

    my $sporring = "SELECT ip,sysname,interface,speed,ro,netident,nettype FROM netbox, gwport, prefix WHERE netbox.netboxid=gwport.netboxid AND gwport.prefixid=prefix.prefixid AND speed='1000' AND masterindex is null ORDER BY sysname";
    my $getinterfaces = &db_select($dbh,$sporring);
    my $antall_interfaces = $getinterfaces->ntuples;
    
    my $tempip = "0";
    my @liste;
    my @liste_bak;
    while (my ($ip,$sysname,$interf,$speed,$community,$nettident,$nettype) = $getinterfaces->fetchrow) {
	$teller++;

	if (($ip eq $tempip || $tempip eq "0") && $teller != $antall_interfaces) {
	    push @liste_bak, [$ip,$sysname,$interf,$nettident,$nettype,$speed,$community];
	    $tempip = $ip;
	} else {
	    
	    if ($teller == $antall_interfaces) {
                push @liste_bak, [$ip,$sysname,$interf,$nettident,$nettype,$speed,$community];
            }

	    @liste = @liste_bak;
	    @liste_bak = ();
	    push @liste_bak, [$ip,$sysname,$interf,$nettident,$nettype,$speed,$community];
	    $tempip = $ip;
	    @liste = &sorter (2,@liste);
	    my $order = @liste;

	    for (@liste) {
		$interfacecount++;
		$antallting++;
		($ip,$sysname,$interf,$nettident,$nettype,$speed,$community) = @$_;

		unless (-e "$path/giga-router-interfaces/$sysname") {
		    mkdir ("$path/giga-router-interfaces/$sysname",0775);
		    $routercount++;
		}

		my $fil = "$path/giga-router-interfaces/$sysname/interfaces";
		if (-e "$path/giga-router-interfaces/$sysname/interfaces") {
		    open (FIL, ">>$fil") or die "Could not open $fil for writing:\n$!\n";
		} else {
		    open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
		    print FIL "target --default--\n";
		    print FIL "\trouter = $ip\n";
		    print FIL "\tsnmp-community =\t$community\n";
		}

		$interf =~ s/\//_/g;
		print FIL "\ntarget \"$interf\"\n";
		$interf =~ s/_/\//g;

		# Legger inn sjekk for om dette er et subinterface, i så fall
		# skal target-type være sub-interface.
		if ($interf =~ m/(.*)\.\d+/) {
		    # Dette er et subinterface.
		    print "Subinterface found: $interf\n";
		    print FIL "\ttarget-type\t=\tsub-interface\n";
		}

		print FIL "\tinterface-name\t=\t\"$interf\"\n";
		print FIL "\tshort-desc\t=\t\"$nettype,$nettident\"\n";
		
		# Setter slik at alle capacities har .00 etter seg
		if ($speed =~ /\./) {
		    print FIL "\tcapacity\t=\t$speed\n";
		} else {
		    print FIL "\tcapacity\t=\t$speed.00\n";
		}

		# Setter sorteringsinfo
		print FIL "\torder\t\t=\t$order\n\n";
		$order--;
	    }
	    close FIL;
	}
    }
    print "$interfacecount ports written, dispersed on $routercount routers.\n"

} # sub gigainterfaces

sub gigaswitchports {

    my $sporring = "SELECT DISTINCT netboxid,ip,sysname,ro,vendorid FROM netbox LEFT JOIN type USING (typeid) JOIN module USING (netboxid) JOIN swport USING (moduleid) WHERE speed=1000 AND (catid ~* '^sw\$' OR catid ~* '^gsw\$')";
    my $getsw = &db_select($dbh,$sporring);
    
    my $switchcount = 0;
    my $portcount = 0;
    while (my @res = $getsw->fetchrow) {
	my ($id, $ip, $switchnavn,$community,$vendorid) = @res;

	if ($community) {
	    my $getports = &db_select($dbh,"SELECT module,port,ifindex,portname,sysname,speed FROM module JOIN swport USING (moduleid) LEFT JOIN netbox ON (swport.to_netboxid=netbox.netboxid) WHERE module.netboxid=$id AND module!='' AND speed=1000 ORDER BY swportid");

	    my $antall = $getports->ntuples;
	    unless ($antall == 0) {
		$switchcount++;
		unless (-e "$path/giga-switch-ports/$switchnavn") {
		    mkdir ("$path/giga-switch-ports/$switchnavn", 0775);
		}

		my $fil = "$path/giga-switch-ports/$switchnavn/ports";

		open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
		print FIL "target --default--\n";
		print FIL "\tswitch\t\t=\t$ip\n";
		print FIL "\tsnmp-community\t=\t$community\n\n";
		
		# Finner alle portene som er på switchen.
		my @liste;
		
		while (my ($modul,$port,$ifindex, $portname,$boksbak,$speed) = $getports->fetchrow) {
#		    print "$ifindex\n";
		    $portname = $portname || $boksbak;
		    unless ($portname) {
			$portname = "Intet portnavn definert";
		    }
		    push @liste, [$modul,$port,$ifindex, $portname,$speed];
		}
		
		@liste = &sorter(2,@liste);
		
		# Order holder styr på rekkefølgen som Cricket
		# viser portene i. Høyt tall = høy prioritet.
		my $order = @liste;
		
		for (@liste) {
		    $portcount++;
		    $antallting++;
		    my ($modul,$port,$ifindex, $portname,$speed) = @$_;
#		    print "$switchnavn: $modul, $port, $ifindex\n";
		    if ($vendorid =~ /hp/) {
			print FIL "target ".$port."\n";
		    } else {
			print FIL "target ".$modul."_".$port."\n";
		    }
		    print FIL "\tinterface-index\t=\t$ifindex\n";
		    $portname =~ s/\s/_/g;
		    print FIL "\tshort-desc\t=\t\"$portname\"\n";
		    
		    $order--;
		    print FIL "\torder\t\t=\t$order\n\n";
		}
	    }
	    close FIL;
	}
    }
    print "$portcount ports written, dispersed on $switchcount switches\n";
}


sub andre_switchports {
    
    # Henter inn alle 3com-svitsjer og C1900or-sw utfra standard på NTNU
    my $sporring = "SELECT netboxid,ip,sysname,ro,typename,typegroupid,vendorid FROM netbox JOIN type USING (typeid) WHERE catid ~* '^SW\$' AND (vendorid = '3com' OR typename ~* 'c1900or\$')";
    my $get3comsw = &db_select($dbh,$sporring);
    
    my $switchcount = 0;
    my $portcount = 0;
    while (my @res = $get3comsw->fetchrow) {
	my ($id, $ip, $switchnavn,$community,$typename,$typegruppe,$vendorid) = @res;

	if ($community) {
	    my $getports = &db_select($dbh,"SELECT module,port,ifindex,portname,speed FROM module JOIN swport USING (moduleid) WHERE netboxid=$id AND module!='' ORDER BY swportid");

	    my $antall = $getports->ntuples;
	    unless ($antall == 0) {
		unless (-e "$path/andre-switch-ports/$switchnavn") {
		    $switchcount++;
		    mkdir ("$path/andre-switch-ports/$switchnavn", 0775);
		}

		my $fil = "$path/andre-switch-ports/$switchnavn/interfaces";

		open (FIL, ">$fil") or die "Could not open $fil for writing:\n$!\n";
		print FIL "target --default--\n";
		print FIL "\tswitch\t\t=\t$ip\n";
		
		print FIL "\tsnmp-community\t=\t$community\n\n";
		
		# Finner alle portene som er på switchen.
		my @liste;
		
		while (my ($modul,$port,$ifindex, $portname,$speed) = $getports->fetchrow) {
#		    print "$ifindex\n";
		    unless ($portname) {
			$portname = "Intet portnavn definert";
		    }
		    push @liste, [$modul,$port,$ifindex, $portname,$speed];
		}
		
		@liste = &sorter(2,@liste);
		
		# Order holder styr på rekkefølgen som Cricket
		# viser portene i. Høyt tall = høy prioritet.
		my $order = @liste;
		
		for (@liste) {
		    $portcount++;
		    $antallting++;
		    my ($modul,$port,$ifindex, $portname,$speed) = @$_;
		    if ($typegruppe eq '3ss') {
			unless ($ifindex =~ /\d\d\d/) {
			    unless ($port =~ /\d\d/) {
				$ifindex = $modul.'0'.$port;
			    }
			}
		    }
#		    print "$switchnavn: $modul, $port, $ifindex\n";
		    print FIL "target \"$modul\_$port\"\n";
		    print FIL "\tinterface-index\t=\t$ifindex\n";
		    $portname =~ s/\s/_/g;
		    print FIL "\tshort-desc\t=\t\"$portname\"\n";
		    
		    $order--;
		    print FIL "\torder\t\t=\t$order\n\n";
		}
	    }
	    close FIL;
	}
    }
    print "$portcount ports written, dispersed on $switchcount switches.\n";
}

sub sorter {

    my $indeks = shift;
    my @array = @_;
    my %temp;
    my %eksisterer;

#    print "\n---------- Ny enhet ---------- Sorterer på $indeks\n";

    for (@array) {
	my $key = @$_[$indeks];
	# Det kan finnes flere interfacer som har samme navn, vi vil
	# bare ha et av dem fordi det er tilstrekkelig.
	unless ($eksisterer{$key}) {
	    $eksisterer{$key}++;

	    my @tall = ();
	    if ($key =~ m(/) ) {
		@tall = split /\//, $key;
		$key = "";
		for (@tall) {
		    #print "$_\n";
		    unless (m/\d{2}/) {
			$_ =~ s/(\d)/0$1/;
		    }
		    $key .= $_;
		}
	    } elsif ($key =~ m/_/) {
		@tall = split /_/, $key;
		$key = "";
		for (@tall) {
		    #print "$_\n";
		    unless (m/\d{2}/) {
			$_ =~ s/(\d)/0$1/;
		    }
		    $key .= $_;
		}
	    } else {
		unless ($key =~ m/\d{2}/) {
		    $key =~ s/(\d)/0$1/;
		}
	    }

	    # Hmm, hva gjør vi nå?
	    my $bokstav = $key;
	    $key =~ s/\D+//g;
	    $bokstav =~ s/\d+//g;
	    $bokstav = ord($bokstav);
	    $key = $bokstav.$key;
	    $temp{$key} = [@$_];
	}
    }
#    print "\nSorterer...\n";
    my @res = sort numerically keys %temp;
    my @ret;
    for (@res) {
#	print "$_ ";
#	print "@{$temp{$_}}\n";
	push @ret, [@{$temp{$_}}];
#	print "pusher @{$temp{$_}}\n";
    }

    return @ret;

}

sub numerically {
    $a <=> $b;
}
