#!/usr/bin/perl -w
############################################################
# Versjon 0.1 ferdig 12-07-2000
# John Magne Bredal
#
# Stakkar akkar den som skal sette seg inn i dette!
#
# Etter ufattelig mange bug-fixes:
# Versjon 0.2 ferdig 14-07-2000
#
# Versjon 0.3 ferdig 21-07-2000
# Forbedret det generelle konfigurasjons-systemet
# Fullstendig funksjonell versjon.
#
# Versjon 0.4 ferdig 25-07-2000
# Forbedret statistikk
# 
# Versjon 0.51 09-03-2001
# Bruker database til skriving av status og sending 
# av beskjeder.
# 
# Versjon 0.6 23-03-2001
# Skriver ikke lenger til fil. Beskjedformatering ferdig.
#
# Versjon 0.7 01-06-01
# Mange mindre fikser og tillegg laget.
# Bruker nå kun statistikk fra databasen
# 
# Versjon 0.8 29.06.01
# Forbedret formatering av sms-meldnger.
# Har nå egen conf-fil for det (smsconfig), med et
# lett system for formatering
############################################################

use strict;
use DBI;

# Filene som brukes av programmet
my $logfil = "/home/trapdet/log/traplog";
my $conf_fil = "/home/trapdet/etc/TrapDetect.conf";
my $servicefil = "/home/trapdet/etc/serviceList";
my $delayedGSMfil = "/home/trapdet/delayedMessages";

# Nye variable som brukes etter nytt system
my $input_oid;
my $input_name;
my $input_ip;
my $sykoid;
my $nettelid = 0;
my @message;

my $date = `date +%D-%T`;
chomp $date;

# To script-variable. scriptbool bestemmer om script skal kjøres, og 
# input inneholder input til scriptet.
my $scriptbool = 0;
my @input;

# Loggfilen som det skrives til. Brukes av blant annet websiden.
open (LOG, ">>$logfil") or die "Kunne ikke åpne $logfil $!\n";
my $dbh = DBI->connect("manage","nett","stotte","mysql");

# Kjører hovedprogrammet
&main();

# Avslutter, skriver litt logg-mat.
$dbh->disconnect;
print LOG "--------------------------------------------------------------------------------\n";
close LOG;

########################################

# Hovedsub'en, tar i mot trap'en og kaller subrutiner som behandler den.
sub main {
    $| = 1;
    chomp (my $name = <STDIN>);
    chomp (my $ip = <STDIN>);
    chomp (my $uptime = <STDIN>);
    
    # Filtrerer vekk .stud.ntnu.no fra $name
    $name =~ s/\..*//;

    my $temp;
    ($temp,$uptime) = split /\s/, $uptime;

    # Input er som sagt kun hvis det kjøres script.
    push @input, $name;
    push @input, $ip;

    my($OID);

    # Holder oversikt om det er funnet en trap.
    my ($bool) = 0;

    # Konstante verdier.
    my $kat1 = 1;
    my $kat2 = 2;
    my $kat3 = 3;
    my $kat;

    # Variablene som angir om trapen angir syk eller frisk state.
    my ($sick, $well) = (0,0);
    my (@OIDliste, @verdiListe);
    my ($sykid, $syk, $friskid, $frisk, $alarm, $script);

    while (<STDIN>) {
	# En generell OID som angir at det er kommet en trap.
	if ($_ =~ m(.1.3.6.1.6.3.1.1.4.1.0)) {
	    # Setter at trap er mottatt.
	    $bool = 1;
	  
	    ($temp, $OID) = split /\s/, $_ ;

	    # Vi vil ikke ha authenticationfailure-traps eller topologychange-traps, spammer noe sinnsykt. Gjør loggen stor.
	    if (($OID eq ".1.3.6.1.6.3.1.1.5.5") or ($OID eq ".1.3.6.1.2.1.17.0.2")) {
		$dbh->disconnect;
		close LOG;
		exit(0);
	    }

	    print LOG "$date\n";
	    print LOG "Uptime: $uptime\n";

	    # Sjekker service-fil.
	    if (&sjekkService($ip, $date)) {
		print LOG "$name, $ip er under service\n";
		print LOG "--------------------------------------------------------------------------------\n";
		close LOG;
		exit(0);
	    }
	    print LOG "Enhet $name, $ip er ikke på service\n"; 

	    print LOG "OID $OID mottatt: ";

	    # Det er generelt 3 typer traps som kan komme inn
	    # coldStart, warmStart er informasjon uten tilstand (sick, well)
	    # Det samme gjelder logoff, reload.
	    # linkDown, linkUp er informasjon med tilstand, med informasjon uten sammenligningsverdier
	    # Det samme gjelder terskel, derfor legger vi dem under kat2
	    # enterpriseSpecific er generelle traps, med informasjon med sammenligningsverdier.
	    # Disse har som regel egne scripts som kalles når trap er mottatt.

	    ($kat, @OIDliste) = &hentInfo($OID);

	    # Globale variable settes
	    $input_name = $name;
	    $sykoid = $OIDliste[0][1];

	    if ($kat == 1) {
		$input_oid = $OIDliste[0][1];

		($sykid, $syk, $alarm) = @{$OIDliste[0]};
		unless ($script) {
		    print LOG "($OIDliste[0][1])\n";
		    push @message, "$OIDliste[0][1] fra $name";
		    push @verdiListe, [$name, $ip, $sykid, $syk, $alarm];

		    &leggInnService($ip, $date);

		} else {
		    $scriptbool = 1;
		    print LOG "Script skal kjøres\n";
		}

	    } elsif ($kat == 2) {
		($sykid, $syk, $friskid, $frisk, $alarm, $script) = @{$OIDliste[0]};
		unless ($script) {
		    if ($sykid =~ m/$OID/) {
			$input_oid = $OIDliste[0][1];

			print LOG "($syk)\n";

			print LOG "Syk funnet, kat: $kat\n";
			push @message, "$syk fra $name";
			push @verdiListe, [$name, $ip, $sykid, $syk, $friskid, $frisk, $alarm];
			$sick = 1;
		    } elsif ($friskid =~ m/$OID/) {
			$input_oid = $OIDliste[0][3];
			print LOG "($frisk)\n";

			print LOG "Frisk funnet, kat: $kat\n";
			push @message, "$frisk fra $name";
			push @verdiListe, [$name, $ip, $sykid, $syk, $friskid, $frisk, $alarm];
			$well = 1;
		    }
		} else {
		    $scriptbool = 1;
		    print LOG "Script skal kjøres\n";
		}

	    } elsif ($kat == 3) {
		    ($sykid, $syk, $friskid, $frisk, $alarm, $script) = @{$OIDliste[0]};
		    
		    # Hvis script, kjører vi dette
		    if ($script) {
			push @verdiListe, [$name, $ip, $sykid, $syk, $friskid, $frisk];
			if ($sykid =~ m/$OID/) {
			    $input_oid = $OIDliste[0][1];

			    print LOG "($syk)\n";

			    print LOG "Syk funnet, kat: $kat\n";
			    $sick = 1;
			} elsif ($friskid =~ m/$OID/) {
			    $input_oid = $OIDliste[0][3];
			    print LOG "($frisk)\n";

			    print LOG "Frisk funnet, kat: $kat\n";
			    $well = 1;
			}
			# Vi skal kjøre et script. Må ha input.
			# Husk - vi har innleggene i Trapdetect.conf i OIDlisten nå
			$scriptbool = 1;
		    } else {
			if ($sykid =~ m/$OID/) {
			    $input_oid = $OIDliste[0][1];

			    print LOG "($syk)\n";

			    print LOG "Syk funnet, kat: $kat\n";
			    push @message, "$syk fra $name";
			    push @verdiListe, [$name, $ip, $sykid, $syk, $friskid, $frisk, $alarm];
			    $sick = 1;
			} elsif ($friskid =~ m/$OID/) {
			    $input_oid = $OIDliste[0][3];
			    print LOG "($frisk)\n";

			    print LOG "Frisk funnet, kat: $kat\n";
			    push @message, "$frisk fra $name";
			    push @verdiListe, [$name, $ip, $sykid, $syk, $friskid, $frisk, $alarm];
			    $well = 1;
			}
		    }
	    } else {
		# Hvis vi kommer hit fant vi ikke trap'en i TrapDetect.conf-fila.
		print LOG "trap ikke funnet\n";
		$bool = 1;
	    }
	    
	} elsif ($bool && !$scriptbool) {
	    # Hvis trap er funnet må vi sjekke om det er flere elementer vi skal ha fra STDIN
	    # Disse elementene ligger i OIDlista.
	    # Hvis de finnes legges de inn i verdilista
	    print LOG "$_";

	    my ($element, $tempoid);
	    foreach $element (@OIDliste) {
		# tempoid er oid'en på trap'en som står i TrapDetect.conf
		$tempoid = @$element[0];
		my ($oid, $value) = split /\s/, $_, 2;
		chomp $value;
		
		# Selvfølgelig spesialtilfelle for NTNU...
		unless ($OID =~ /(2595|3001)/) {
		    # Tar vekk siste tallet i OID'en.
		    $oid =~ s/(\.\d+)$//;
		}

		if ($oid eq $tempoid) {
		    if ($value) { # hvis det ikke finnes noen verdi
			push @verdiListe, [@$element[1], $value];
			push @message, "@$element[1] = $value";
			
			
			# Sjekker om det er en nettelid-verdi her. I så fall settes variabelen
			# nettelid, slik at vi vet hva vi skal gjøre når vi skal sende meldinger.
			if (@$element[1] =~ /nettelid/i) {
			    $nettelid = $value;
			}
		    } else {
			print LOG "@$element[1] har ingen verdi!\n";
		    }
		}
	    }
	} elsif ($scriptbool) {
	    # Legger alt klart til kjøring av script. Parrer input.
	    print LOG "$_";
	    chomp $_;
	    my ($temp1, $temp2) = split /\s/, $_;
	    push @input, "$temp1=$temp2";
	} 
    }

    # All informasjon er nå samlet inn fra snmp-trap'en.
    # Kan nå begynne å skrive/slette og sende beskjeder.

    # Disse tar for seg kat2 og kat3 (kat1 er ferdig).
    # Sender beskjeder og skriver inn i syk-fila.

    # Hvis det er et script som kjøres.
    if ($scriptbool) {
	if (-e "home/trapdet/bin/$script") {
	    print LOG "Kjører script $script\n";
	    @message = `perl home/trapdet/bin/$script $OID @input`;
	    
	    if ($sick) {
		# Sjekker om innlegget finnes fra før - i så fall slettes det.
		if (my @id = &sjekkDB($kat, @message)) {
		    my $antall_innlegg = @id;
		    print LOG "Fant $antall_innlegg innlegg i databasen..sletter";
		    for (@id) {
			slettFraDB($_);
		    }
		    print LOG "Ferdig!\n";
		}
		print LOG "Kaller leggInnStatus\n";
		&leggInnStatus($kat, @verdiListe);
	    } elsif ($well) {
		if (my @id = &sjekkDB($kat, @message)) {
		    # Oppdaterer feltet i databasen.
		    my $antall_innlegg = @id;
		    print LOG "Fant $antall_innlegg innlegg i databasen";
		    if ($antall_innlegg > 1) {
			my $siste = pop @id;
			print LOG ", sletter ekstra innlegg: ";
			for (@id) {
			    &slettFraDB($_);
			    print LOG "$_ ";
			}
			print LOG ", friskmelder $siste ...";
			&friskmeld($siste);
		    } else {
			my $id = pop @id;
			print LOG ", friskmelder $id ...";
			&friskmeld($id);
		    }
		    print LOG " ..Ferdig!\n";
		    &sendAlarm();
		}
	    }
	} else {
	    print LOG "Finner ikke $script\n";
	}
    # Kjører dette hvis det ikke er et script som kjører.
    } elsif ($kat == 1) {
	&leggInnStatus($kat, @verdiListe);
	&sendAlarm();
    } elsif ($sick) {
	# Sjekker om innlegg finnes i databasen, hvis det finnes
	# slettes alle
	if (my @id = &sjekkDB($kat, @verdiListe)) {
	    my $antall_innlegg = @id;
	    print LOG "Fant $antall_innlegg innlegg i databasen..sletter";
	    for (@id) {
		slettFraDB($_);
	    }
	    print LOG "Ferdig!\n";
	}
	# Alle gamle innlegg skal nå være borte.
	# Skriver til databasen
	print LOG "Kaller leggInnStatus\n";
	&leggInnStatus($kat, @verdiListe);
	&sendAlarm();
    } elsif ($well) {
	# Sjekker databasen for den tilsvarende sykmeldingen, og oppdaterer feltet.
	if (my @id = &sjekkDB($kat, @verdiListe)) {
	    # Oppdaterer feltet i databasen.
	    my $antall_innlegg = @id;
	    print LOG "Fant $antall_innlegg innlegg i databasen";
	    if ($antall_innlegg > 1) {
		my $siste = pop @id;
		print LOG ", sletter ekstra innlegg: ";
		for (@id) {
		    &slettFraDB($_);
		    print LOG "$_ ";
		}
		print LOG ", friskmelder $siste ...";
		&friskmeld($siste);
	    } else {
		my $id = pop @id;
		print LOG ", friskmelder $id ...";
		&friskmeld($id);
	    }
	    print LOG " ..Ferdig!\n";
	    &sendAlarm();
	} else {
	    print LOG "Fant ikke innlegget i databasen\n";
	}
    } else {
	print LOG "No state\n";
    }
}

##################################################
# Henter oid og beskrivelse fra TrapDetect.conf
##################################################
sub hentInfo {
    # Må finne ut hvilken type melding det er.
    my $oid = shift;

    my $kat = 0;
    my ($sykid, $syk, $friskid, $frisk, $alarm, $script) = (0,0,0,0,0,0);
    my ($linje, $lengde, @liste, @OIDliste);
    my ($funnet,$teller) = (0,0);

    open (HANDLE, $conf_fil) or die "Kunne ikke åpne $conf_fil\n";
    while (<HANDLE>) {
	unless (/^\#/) { # Skipper kommentarer
	    if ((/^kat(\d)/i) && !($funnet)) {
		$kat = $1;
	    } elsif (/$oid/) {
		$funnet = 1;
		if ($kat == 1) {
		    ($sykid, $syk, $alarm, $script) = split /\s/, $_;
		    chomp $alarm;
		    push @OIDliste, [$sykid, $syk, $alarm, $script];

		    $teller = 0;
		    until (($linje = <HANDLE>) =~ /^-/) {
			$teller++;
			chomp $linje;
			@liste = split /\s/, $linje;
			push @OIDliste, [@liste];
			if ($teller > 100) { die "Uendelig loop!\n"; }
		    }
		} else {
		    ($sykid, $syk, $friskid, $frisk, $alarm, $script) = split /\s/, $_;
		    push @OIDliste, [$sykid, $syk, $friskid, $frisk, $alarm, $script];
		    $teller = 0;
		    # Henter ut resten av info som ligger under hovedOID'en
		    until (($linje = <HANDLE>) =~ /^-/) {
			$teller++;
			chomp $linje;
			@liste = split /\s/, $linje;
			push @OIDliste, [@liste];
			if ($teller > 100) { die "Uendelig loop!\n"; }
		    }
		}
	    }
	}
    }
    
    if ($funnet) {
	return ($kat,@OIDliste);
    } else {
	return $funnet;
    }
 
    close HANDLE;
}

##################################################
# Legger inn en ip og date i service-fila
# Format på date må være yymmdd-hhmmss
##################################################
sub leggInnService {

    my ($ip, $date) = @_;

    open (SERVICE, ">>$servicefil") or die "Kunne ikke åpne $servicefil for skriving $!\n";
    print SERVICE "$ip date:$date\n";
    close SERVICE;

}

##################################################
# Leter etter ip-adresse i service-fila
# Sammenligner med dato for å sjekke om den skal ut eller ikke.
# Returnerer 1 hvis funnet, 0 ellers.
##################################################
sub sjekkService {

    my ($ip, $date) = @_;
    my $clock;
    ($date,$clock) = split /-/, $date;
    my ($month, $day, $year) = split /\//, $date;
    my ($hh, $mm, $ss) = split /:/, $clock;
    my $funnet = 0;

    open (SERVICE, $servicefil) or die "Kunne ikke åpne $servicefil $!\n";
    my @fil = <SERVICE>;
    close SERVICE;
    
    my $inndato = $year.$month.$day; 
    my $inntime = $hh.$mm.$ss;

    my $entry;
    open (SERVICE, ">$servicefil") or die "Kunne ikke åpne $servicefil $!\n";
    for $entry (@fil) {
	unless ($entry =~ m/^\#/) {
	    if ($entry =~ m/$ip/) {
		#                       day  month  year   hour   min   sek
		if ($entry =~ m/date:(\d\d)(\d\d)(\d\d)-(\d\d)(\d\d)(\d\d)/) {
		    my $fildato = $3.$2.$1; 
		    my $filtime = $4.$5.$6; 
		    if ($fildato < $inndato) {
			# ta enhet ut av service
		    } elsif ($fildato > $inndato) {
			# returnerer true - enheten er på service
			print SERVICE $entry;
			$funnet = 1;
		    } elsif ($fildato == $inndato) {
			if ($filtime > $inntime) { 
			    # returnerer true - enheten er på service
			    print SERVICE $entry;
			    $funnet = 1;
			} else {
			    # ta enhet ut av service
			}
		    }
		}
	    } else {
		print SERVICE $entry;
	    }
	} else {
	    print SERVICE $entry;
	}
    }
    return $funnet;
}

##################################################
# Tar i mot en alarm og en melding, slår opp i 
# alarmList-fila for å finne passende 
# alarm og sender så til denne adressen.
##################################################
sub sendAlarm {
    # Vi har disse variablene:
    # input_oid: oid som beskriver trap'en
    # input_name: enhet trap'en kom fra
    # nettelid: suboid som inneholder nettelid til enhet
    # melding: inneholder alt som er i beskjeden
    unless ($nettelid) {
	$nettelid = &finn_nettelid($input_name);
    } else {
	# Fjerner ting som ikke er tall fra nettelid
	$nettelid =~ s/\D//g;
    }

    my $beskjedbool = 0;
    my $gruppeid;
    my (@mail_liste, @sms_liste, @delay_liste);

    my $finn_info = $dbh->prepare("SELECT kat, underkat, eier, ip, active FROM nettel where id=$nettelid");
    unless ($finn_info->execute) {
	print LOG "Finner ikke enhet med nettelid $nettelid\n";
    }
    
    my @enhet_liste = $finn_info->fetchrow_array;
    my $active = pop @enhet_liste;

    # Hvis enheten er på service skal vi ikke sende beskjed.
    if ((not defined($active)) || $active =~ /Y/i) {
	$input_ip = pop @enhet_liste;
	# Setter tomme variable til NULL
	for (@enhet_liste) {
	    unless ($_) { $_ = "NULL"; }
	}

	print LOG "Enhet_liste: @enhet_liste\n";

	# Sjekker om vi skal sende beskjed i det hele tatt.
	my $finn_gruppe = $dbh->prepare("SELECT id,trap,kat,ukat,eier FROM vgruppe");
	$finn_gruppe->execute;

	while (my @gruppe_liste = $finn_gruppe->fetchrow_array) {
	    # Setter tomme variable til NULL
	    for (@gruppe_liste) {
		unless ($_) { $_ = "NULL"; }
	    }
	    #print LOG "Gruppe_liste: @gruppe_liste\n";
	    # Hvis trap'en er den samme må vi sjekke videre
	    if ($gruppe_liste[1] =~ /$sykoid/i) {
		if ($gruppe_liste[2] =~ /$enhet_liste[0]|null/i && $gruppe_liste[3] =~ /$enhet_liste[1]|null/i && $gruppe_liste[4] =~ /$enhet_liste[2]|null/i) {
		    print LOG "Alle sjekkene gikk gjennom, skal sende beskjed til gruppe $gruppe_liste[0]\n";
		    $beskjedbool = 1;
		    $gruppeid = $gruppe_liste[0];
		    last;
		}
	    }
	}
    }

    # Hvis vi skal sende beskjeder kjøres denne.
    if ($beskjedbool) {
	print LOG "\nFinner ut hvem vi skal sende beskjed til...\n";
	# Må finne ut til hvem vi skal sende beskjed
	my $finn_brukere = $dbh->prepare("SELECT id,varseltype,mail,tlf,status from user,varsel where gruppeid=$gruppeid AND varsel.userid=user.id");
	$finn_brukere->execute;

	while (my($brukerid,$varseltype,$mail,$tlf,$status) = $finn_brukere->fetchrow_array) {
	    unless ($varseltype =~ /fri/i || $status =~ /fri/i) {
		if ($varseltype =~ /mail/i) {
		    push @mail_liste, $mail;
		}
		if ($varseltype =~ /dsms/i) {
		    push @delay_liste, $brukerid;
		} elsif ($varseltype =~ /sms/i) {
		    push @sms_liste, $brukerid;
		}
	    }
	} # while

	# Traverserer alle lister og sender tilhørende beskjeder
	for (@mail_liste) {
	    # Sender mail
	    &send_mail($_);
	}
	for (@sms_liste) {
	    # Sender sms, dvs. legger melding inn i database
	    &send_sms($_);
	}
	for (@delay_liste) {
	    # Sender delayed melding.
	    # Må sjekke for hver bruker hva han er satt opp på
	    my $sporring = $dbh->prepare("Select dsms_fra,dsms_til from user where id=?");
	    $sporring->execute($_);
	    
	    my ($fra,$til) = $sporring->fetchrow_array;
	    my @temp = split /:/, $fra;
	    $fra = "";
	    for (@temp) {
		$fra .= $_;
	    }
	    @temp = split /:/, $til;
	    $til = "";
	    for (@temp) {
		$til .= $_;
	    }

	    chomp (my $tid=`date +%H%M%S`);

	    if (($fra > $tid) && ($til < $tid)) {
		print LOG "Sender beskjed til $_\n";
		&send_sms($_);
	    } else {
		print LOG "Sender ikke sms-beskjed til $_: $fra > $tid > $til\n";
	    }

	    $sporring->finish;
	}
    } else {
	# Gjør ingenting hvis ikke beskjedbool er satt.
    }

}

##################################################
# Sjekker om et innlegg finnes i databasen. 
# Alle innlegg som ble funnet sendes returneres
# som en liste. Hvis ingen innlegg finnes
# returneres en tom liste.
##################################################
sub sjekkDB {

    my @liste = @_;
    my $kat = shift @liste;
    my $element = shift @liste;

    my (@innlegg,$id,$til);
    my ($trapsource,$ip,$oidnum,$trap,$trenger,$ikke,$disse) = @$element;

    my @temp_oid_liste = hentsuboid($trap);

    my $trapdescr;
    # Hiver alle suboid'er inn i en tekststreng og sjekker.
    foreach $element (@liste) {
	# Hvis det er en variabel verdi, så kan vi ikke bruke den som letegrunnlag.
	unless (@$element[0] =~ /\*/g) {
	    $trapdescr .= "@$element ";
	}
    }

    # Henter nettelid fra database ut fra input_name-variabel
    unless ($nettelid) {
    $nettelid = &finn_nettelid($input_name);
    } else {
    # Fjerner ting som ikke er tall fra nettelid
    $nettelid =~ s/\D//g;
    }

    # Spør først etter hovedfeltene
    unless ($kat == 3) {
	my $sporring = $dbh->prepare("SELECT id,til FROM status WHERE trapsource='$trapsource' AND trap='$trap' AND nettelid=$nettelid AND trapdescr='$trapdescr'");
	$sporring->execute;

	while (($id,$til) = $sporring->fetchrow_array) {
	    if ($id && not $til) {
		# Fant innlegget, returnerer 1
		#print LOG "Fant innlegget i databasen - $id\n";
		push @innlegg, $id;
	    } elsif ($id && $til) {
		# Fant friskmeldt innlegg
		#print LOG "Fant friskmeldt innlegg - $id\n";
		$id = 0;
	    } else {
		# Fant ikke innlegget, returnerer 0
		print LOG "Fant IKKE innlegget i databasen\n";
		$id = 0;
	    }
	}
    } else {
	print LOG "Kategori 3 funnet\n";
#	print LOG "SELECT id,til,trapdescr FROM status WHERE trapsource='$trapsource' AND trap='$trap' AND nettelid=$nettelid\n";
	my $sporring = $dbh->prepare("SELECT id,til,trapdescr FROM status WHERE trapsource='$trapsource' AND trap='$trap' AND nettelid=$nettelid");
	$sporring->execute;

	my @temp_oid_liste_bak = &hentsuboid($trap);

	while (($id,$til,my $trapdes) = $sporring->fetchrow_array) {
	    # Splitter innholdet i trapdescr inn i en liste
	    my $temp;
	    my $tempsuboid;
	    my $funnetoid = 0;
	    
	    my @temp_oid_liste = @temp_oid_liste_bak;
	    my @liste = split /\s/, $trapdes;
	    $tempsuboid = shift @temp_oid_liste;
	    for (@liste) {
		if ($_ !~ m/\*/ && $tempsuboid eq $_) {
		    $temp .= "$_ ";
		    $funnetoid = 1;
		    $tempsuboid = shift @temp_oid_liste;
		} elsif ($_ =~ m/\*/ && $tempsuboid eq $_) {
		    $funnetoid = 0;
		    $tempsuboid = shift @temp_oid_liste;
		} elsif ($funnetoid) {
		    $temp .= "$_ ";
		}
	    }
	    $trapdescr =~ s/\"//g;
	    $temp =~ s/\"//g;
#	    print LOG "START: \n$temp -> \n$trapdescr";
	    if ($trapdescr eq $temp) {
		#print LOG " = like\n";
		if ($id && not $til) {
		    # Fant innlegget, returnerer 1
		    print LOG "Fant innlegget i databasen - $id\n";
		    push @innlegg, $id;
		} elsif ($id && $til) {
		    # Fant friskmeldt innlegg
		    print LOG "Fant friskmeldt innlegg - $id\n";
		    $id = 0;
		} else {
		    # Fant ikke innlegget, returnerer 0
		    print LOG "Fant IKKE innlegget i databasen\n";
		    $id = 0;
		}
	    } else {
		 #print LOG " = ikke like\n";
	    }
	}
    }
    return @innlegg;
}

##################################################
# En liten sub som henter inn suboid'er 
# fra TrapDetect.conf
##################################################
sub hentsuboid {
    
    my $oid = shift @_;
    my $funnet = 0;
    my @temparray;
    my @liste;
    
    open (FIL, "/home/trapdet/etc/TrapDetect.conf") || die "Kunne ikke aapne fil\n$!\n";
    while (<FIL>) {
	if (/$oid/gi) {
	    $funnet = 1;
	} elsif ($funnet && $_ !~ /^-/) {
	    @temparray = split;
	    push @liste, $temparray[1];
	} elsif (/^-/ && $funnet) {
	    last;
	}
    }
    
    close FIL;
    
    return @liste;
}

##################################################
# Legger inn innlegget i databasens
# status tabell.
# Tar inn verditabellen som inneholder
# alle data + suboid'er.
# FORMAT verdiliste:
# Kat1: <navn><ip><oidtall><oidnavn><alarm>
#       <suboid'er>
# Kat2: <navn><ip><sykoidtall><sykoidnavn><friskoidtall><friskoidnavn><alarm>
#       <suboid'er>
##################################################
sub leggInnStatus {

    my @liste = @_;

    my $kat = shift @liste;
    my $element = shift @liste;

    my ($trapsource, $trap) = (@$element[0],@$element[3]);
    my $trapdescr;

    # Finner nettelid oppdatert av KHV 28.04.2001 
    unless ($nettelid) {
	$nettelid = &finn_nettelid($input_name);
	unless ($nettelid) {
	    $nettelid = 0;
	}
    } else {
    # Fjerner ting som ikke er tall fra nettelid
	$nettelid =~ s/\D//g;
    }

    foreach $element (@liste) {
	$trapdescr .= "@$element ";
    }
    my $tilstandsfull;
    if ($kat == 1) {
	$tilstandsfull = "N";
    } else {
	$tilstandsfull = "Y";
    }

    if ($trap =~ /flow/) {
	print LOG "$trapsource\n$trap\n$trapdescr\n$nettelid\n";
    }

    my $ok = $dbh->do("insert into status (trapsource,trap,trapdescr,tilstandsfull,nettelid,fra) values ('$trapsource','$trap','$trapdescr','$tilstandsfull',$nettelid,now())");

    if ($ok) {
	print LOG "Innlegg lagt i DB\n";
    } else {
	print LOG "Databasen ikke oppdatert!\n";
    }
}

########################################
# Tar inn en id til et element i databasen
# og sletter det.
########################################
sub slettFraDB {

    my $id = shift;
    $dbh->do("DELETE FROM status WHERE id=$id");

}

########################################
# Tar inn en id til et element i databasen
# og friskmelder det.
########################################
sub friskmeld {

    my $id = shift;
    $dbh->do("UPDATE status SET til=now() WHERE id=$id");

}


##################################################
# En subrutine som tar inn en mail-adresse 
# og sender mail til vedkommende.
##################################################
sub send_mail {

    use Mail::Sendmail;

    my %mail;
    my $to_address = shift;

    print LOG "Sender mail til $to_address\n";

    my @mail_message = @message;
    $mail{'Subject'} = shift @mail_message;

    my $beskjed;
    for (@mail_message) {
	$beskjed .= "$_ \n";
    }
    $beskjed =~ s/\"//g;

    ($mail{'To'},$mail{'Message'}) = ($to_address,$beskjed);
    
    $mail{'from'} = "TrapDetect <nettstotte\@itea.ntnu.no>";
    $mail{'smtp'} = 'bigbud.itea.ntnu.no';
    
    if (sendmail %mail) { print "Mail sent OK.\n" }
    else { print "Error sending mail: $Mail::Sendmail::error \n" }
}

##################################################
# En subrutine som tar inn et tlf-nummer og 
# legger et innlegg i databasen for sending.
#
# Når vi sender sms må vi kutte ned på meldingen
# slik at den blir så kort som mulig. Dette 
# fører til at vi må ha en egen sub som er
# konfigurert for hver eneste trap som kan tas
# imot. Kjedelige greier...
##################################################
sub send_sms {

    my $melding;
    my $brukerid = shift;
    print LOG "Sender sms til $brukerid\n";

    # Kutter ned på meldingen
    print LOG "Formaterer melding til sms\n";
    my $formatert_melding = &format_sms();
    $formatert_melding =~ s/\"//g;

    # Legger meldingen inn i databasen
    print LOG "Legger meldingen inn i databasen...";

    my $ok = $dbh->do("INSERT INTO smsutko (userid, tidspunkt, melding, sendt) VALUES ('$brukerid', now(), '$formatert_melding', 'N')");

    if ($ok) {
	print LOG "\tFERDIG\n";
    } else {
	print LOG "det gikk heller dårlig..\n";
    }

}

##################################################
# Finner nettelid til et gitt sysname
##################################################
sub finn_nettelid {

    my $sysname = shift;

    # Hardkoder unntak siden navnekonvensjoen er feil når det
    # gjelder disse ruterne.
    if ($sysname =~ m/trlos/) {
	print LOG "$sysname ->";
	$sysname =~ s/-trlos//;
	print LOG " $sysname\n";
    }

    # Slår opp i database og henter nettelid til sysname
    my $finn_nettelid = $dbh->prepare("SELECT id FROM nettel WHERE sysname='$sysname'");
    $finn_nettelid->execute;

    my $id = $finn_nettelid->fetchrow_array;

    unless ($id) {
	print LOG "Setter id til null\n";
	$id = 0;
    }

    return $id;

}

##################################################
# Generell formatering av meldinger som skal sendes 
# vha. sms. Bruker filen smsconfig som ligger i etc/ 
# til å lese inn formateringsinfo.
##################################################
sub format_sms {
    
    my $oid = $input_oid;
    my $funnet = 0;
    my $innlegg = "";

    # Leser inn formateringsinfo fra fil.
    open (FIL, "/home/trapdet/etc/smsconfig") or die "Kunne ikke åpne fil $!\n";
    while (<FIL>) {
	# Hopper over kommentarer
	unless (/^\#/) {
	    if (/^$oid/) {
		chomp;
		print LOG "Fant oid i fil: $_\n";
		$funnet = 1;
		$innlegg = $_;
	    }
	}
    }
    close FIL;

    if ($funnet) {
	my %var = (); # Her legges suboider

	# Message må ikke forandres!
	my @temp_message = @message;

	# Parser message
	my @temp = split /\s/, (shift @temp_message);
	$var{"avsender"} = $temp[2];
	for (@temp_message) {
	    @temp = split;
	    my $suboid = shift @temp;
	    shift @temp; # fjerner =
	    my $temp_streng;
	    while (my $temp = shift @temp) {
		$temp_streng .= $temp." ";
	    }
	    chop $temp_streng;
	    $var{$suboid} = $temp_streng;
	    $temp_streng = "";
	}

	# Replacer alle instanser av variable som er lik
	# suboider i config-fila.
	my @suboid = keys (%var);
	for (@suboid) {
	    $innlegg =~ s/\$$_/$var{$_}/;
	}
	print LOG $innlegg."\n";
	return $innlegg;
    } else {
	print LOG "Fant ikke innlegg i config-fil.\n";
    }

} # End format_sms
